# -*- coding: utf-8 -*-
"""BFS_Missionaries_and_Cannibles.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VhACA7Tep3C7EGYgercFwMH3yDAFi5UL

Missonaries and cannible problem.
===========================================================

Importing modules and Defining jug capacities
"""

from time import time
import copy

"""One missionary go to other side of the river"""

def M(left_state):
  state=left_state[:]
  if left_state[0]<left_state[1] and left_state[0]!=0:return None
  if (3-left_state[0])<(3-left_state[1]) and (3-left_state[0]!=0): return None

  if left_state[-1]==1 and left_state[0]>0:
    left_state[0]-=1
    left_state[-1]=0
  elif left_state[0]<3:
    left_state[0]+=1
    left_state[-1]=1

  if left_state[0]<left_state[1] and left_state[0]!=0: return None
  if (3-left_state[0])<(3-left_state[1]) and (3-left_state[0]!=0):return None
  if state==left_state:return None

  return left_state

#Driver code
left_state=[3,2,1] #[M,C,B]
print(M(left_state))

"""One Cannible go to other side of the river"""

def C(left_state):
  state=left_state[:]
  if left_state[0]<left_state[1] and left_state[0]!=0:return None
  if (3-left_state[0])<(3-left_state[1]) and (3-left_state[0]!=0): return None

  if left_state[-1]==1 and left_state[1]>0:
    left_state[1]-=1
    left_state[-1]=0
  elif left_state[1]<3:
    left_state[1]+=1
    left_state[-1]=1

  if left_state[0]<left_state[1] and left_state[0]!=0:return None
  if (3-left_state[0])<(3-left_state[1]) and (3-left_state[0]!=0): return None
  if state==left_state:return None

  return (left_state)

#Driver code
left_state=[3,3,1] #[M,C,B]
print(C(left_state))

"""Two Missionaries go to other side of the river"""

def MM(left_state):
  state=left_state[:]
  if left_state[0]<left_state[1] and left_state[0]!=0:return None
  if (3-left_state[0])<(3-left_state[1]) and (3-left_state[0]!=0): return None

  if left_state[-1]==1 and left_state[0]>1:
    left_state[0]-=2
    left_state[-1]=0
  elif left_state[0]<2:
    left_state[0]+=2
    left_state[-1]=1

  if left_state[0]<left_state[1] and left_state[0]!=0:return None
  if (3-left_state[0])<(3-left_state[1]) and (3-left_state[0]!=0): return None
  if state==left_state:return None

  return (left_state)

#Driver code
left_state=[2,2,1] #[M,C,B]
print(MM(left_state))

"""Two Cannible go to other side of the river"""

def CC(left_state):
  state=left_state[:]
  if left_state[0]<left_state[1] and left_state[0]!=0:return None
  if (3-left_state[0])<(3-left_state[1]) and (3-left_state[0]!=0): return None

  if left_state[-1]==1 and left_state[1]>1:
    left_state[1]-=2
    left_state[-1]=0
  elif left_state[1]<2:
    left_state[1]+=2
    left_state[-1]=1
  
  if left_state[0]<left_state[1] and left_state[0]!=0:return None
  if (3-left_state[0])<(3-left_state[1]) and (3-left_state[0]!=0): return None
  if state==left_state:return None

  return (left_state)

#Driver code
left_state=[2,2,1] #[M,C,B]
CC(left_state)

"""One Missonariy one Cannible go to other side of the river"""

def MC(left_state):
  state=left_state[:]
  if left_state[0]<left_state[1] and left_state[0]!=0:return None
  if (3-left_state[0])<(3-left_state[1]) and (3-left_state[0]!=0): return None

  if left_state[-1]==1 and (left_state[0]>0 and left_state[1]>0) :
    left_state[0]-=1
    left_state[1]-=1
    left_state[-1]=0
  elif left_state[0]<3 and left_state[1]<3:
    left_state[0]+=1
    left_state[1]+=1
    left_state[-1]=1
  
  if left_state[0]<left_state[1] and left_state[0]!=0:return None
  if (3-left_state[0])<(3-left_state[1]) and (3-left_state[0]!=0): return None
  if state==left_state:return None

  return (left_state)

#Driver code
left_state=[3,3,1] #[M,C,B]
print(MC(left_state))

"""Find path function defination. This function will find the intermediate states of a missonaries and cannible problem"""

def find_path(parents):
    path=[]
    path.append(parents[len(parents)-1][1])
    path.append(parents[len(parents)-1][0])
    x=parents[len(parents)-1][0]
    for parent in range(len(parents)-2,-1,-1):
        if parents[parent][1]==x:
            x=parents[parent][0]
            path.append(x)
    return path
#drivers code
x=find_path([['E', 'A'], ['E', 'B'], ['E', 'D'], ['E', 'H'], ['A', 'C'], ['H', 'F'], ['C', 'G']])
print(x)

"""BFS goal state function defination"""

def bfs_goal_search(start,goal):
    # keep track of all visited nodes
    explored = []
    # keep track of nodes to be checked
    queue = [start]
    neighbour=[]
    parents=[]
    
    if(start==goal):
        return(print("start is goal"))

    c=0
    while queue:
        c+=1
        node = queue.pop(0)
        print('c=',c,' | node=',node)
        if node not in explored:
            # add node to list of checked nodes
            explored.append(node[:])
        neighbour = M(node[:])
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour[:])
                parents.append([node[:],neighbour[:]])
            if neighbour == goal:
                return find_path(parents)
                    
        neighbour = C(node[:])
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour[:])
                parents.append([node[:],neighbour[:]])
            if neighbour == goal:
                return find_path(parents)
        
        neighbour = MM(node[:])
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour[:])
                parents.append([node[:],neighbour][:])
            if neighbour == goal:
                return find_path(parents)
            
        neighbour = CC(node[:])
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour[:])
                parents.append([node[:],neighbour[:]])
            if neighbour == goal:
                return find_path(parents)

        neighbour = MC(node[:])
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour[:])
                parents.append([node[:],neighbour[:]])
            if neighbour == goal:
                return find_path(parents)
     
# driver code      
start = [0,0,0]
goal = [3,3,1]
print('Solution of Missionaries and cannible problem.')
print('==============================================')
s_time = time()
solutions = bfs_goal_search(start,goal)
e_time = time()
solutions=solutions[::-1]
print()
for solution in solutions:
  print(solution)
print('\nTime =',e_time-s_time)

def bfs_goal_search(start,goal):
    # keep track of all visited nodes
    explored = []
    # keep track of nodes to be checked
    queue = [start]
    neighbour=[]
    parents=[]
    
    if(start==goal):
        return(print("start is goal"))

    c=0
    while queue:
        c+=1
        node = queue.pop(0)
        print('c=',c,' | node=',node)
        if node not in explored:
            # add node to list of checked nodes
            explored.append(node[:])
        neighbour = M(node[:])
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour[:])
                parents.append([node[:],neighbour[:]])
            if neighbour == goal:
                return find_path(parents)
                    
        neighbour = C(node[:])
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour[:])
                parents.append([node[:],neighbour[:]])
            if neighbour == goal:
                return find_path(parents)
        
        neighbour = MM(node[:])
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour[:])
                parents.append([node[:],neighbour][:])
            if neighbour == goal:
                return find_path(parents)
            
        neighbour = CC(node[:])
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour[:])
                parents.append([node[:],neighbour[:]])
            if neighbour == goal:
                return find_path(parents)

        neighbour = MC(node[:])
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour[:])
                parents.append([node[:],neighbour[:]])
            if neighbour == goal:
                return find_path(parents)
     
# driver code      
start = [3,3,1]
goal = [0,0,0]
print('Solution of Missionaries and cannible problem.')
print('==============================================')
s_time = time()
solutions = bfs_goal_search(start,goal)
e_time = time()
solutions=solutions[::-1]
print()
for solution in solutions:
  print(solution)
print('\nTime =',e_time-s_time)