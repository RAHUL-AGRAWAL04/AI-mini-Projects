# -*- coding: utf-8 -*-
"""2_Water_Jug_Problem_BFS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17rzHjA7B6O_ipckbB7fbgA6XNg7Hq015

## BFS - 2 Water Jug Problem - 4L from 8L, 5L Jug capacities 
###{(0,0)->(4,0)}
"""

import time
import copy
jug1 = 8
jug2 = 5

"""### Fill water in jug A from tap"""

def fill_water_in_jug_A_from_tap(capacity):
    current_a = capacity[0]
    current_b = capacity[1]
    return [jug1,current_b]
            
# driver code:
new_A = fill_water_in_jug_A_from_tap([0,0])
print(new_A)

"""### Fill water in jug B from tap"""

def fill_water_in_jug_B_from_tap(capacity):
    current_a = capacity[0]
    current_b = capacity[1]
    return [current_a,jug2]
            
# driver code:
new_B = fill_water_in_jug_B_from_tap([2,3])
print(new_B)

"""### Empty water from jug A on the ground"""

def empty_jug_A_on_ground(capacity):
    current_a = capacity[0]
    current_b = capacity[1]
    return [0,current_b]
            
# driver code:
new_A = empty_jug_A_on_ground([8,2])
print(new_A)

"""### Empty water from jug B on the ground"""

def empty_jug_B_on_ground(capacity):
    current_a = capacity[0]
    current_b = capacity[1]
    return [current_a,0]
            
# driver code:
new_B = empty_jug_B_on_ground([5,4])
print(new_B)

"""### Pour water from jug A to jug B until A get empty or B get full"""

def pour_water_from_A_to_B(capacity):
    current_a = capacity[0]
    current_b = capacity[1]
    available_capacity = jug2-current_b
    while True:
      if (current_a<=0 or current_b>=jug2) or available_capacity<=0:
          break
      else:
        available_capacity -= 1
        current_a -= 1
        current_b += 1
    return [current_a,current_b]       
# driver code:
new_states = pour_water_from_A_to_B([8,2])
print(new_states)

"""### Pour water from jug B to jug A until B get empty or A get full"""

def pour_water_from_B_to_A(capacity):
    current_a = capacity[0]
    current_b = capacity[1]
    available_capacity = jug1-current_a
    while True:
      if (current_a>=jug1 or current_b<=0) or available_capacity<=0:
          break
      else:
        available_capacity -= 1
        current_a += 1
        current_b -= 1
    return [current_a,current_b]       
            
# driver code:
new_states = pour_water_from_B_to_A([6,5])
print(new_states)

"""### Searching goal node """

def bfs_goal_search(start,goal):
    # keep track of all visited nodes
    explored = []
    # keep track of nodes to be checked
    queue = [start]
    neighbour=[]
    parents=[]
    
    if(start==goal):
        return(print("start is goal"))

    c=0
    while queue:
        c=c+1
        print(c)
        # pop shallowest node (first node) from queue
        node = queue.pop(0)
        print("node=",node)
        if node not in explored:
            # add node to list of checked nodes
            explored.append(node)

        neighbour = fill_water_in_jug_A_from_tap(node)
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour)
                parents.append([node,neighbour])
            if neighbour == goal:
                return neighbour
                    
        neighbour = fill_water_in_jug_B_from_tap(node)
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour)
                parents.append([node,neighbour])
            if neighbour == goal:
                return neighbour
        
        neighbour = empty_jug_A_on_ground(node)
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour)
                parents.append([node,neighbour])
            if neighbour == goal:
                return neighbour
            
        neighbour = empty_jug_B_on_ground(node)
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour)
                parents.append([node,neighbour])
            if neighbour == goal:
                return neighbour

        neighbour = pour_water_from_A_to_B(node)
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour)
                parents.append([node,neighbour])
            if neighbour == goal:
                return neighbour

        neighbour = pour_water_from_B_to_A(node)
        if neighbour != None:
            if neighbour not in queue and neighbour not in explored :
                queue.append(neighbour)
                parents.append([node,neighbour])
            if neighbour == goal:
                return neighbour
            
     
# driver code      
start1 = [0,0]
goal1 = [4,0]
bfs_goal_search(start1,goal1)