# -*- coding: utf-8 -*-
"""A_STAR_8_Puzzle_h1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZpN8O_a5adUVHUMTgPjosQyoX9cQmJ5o
"""

from copy import deepcopy
import heapq
from time import time
#form collections import deque

# All function uses initial_state matrix as their input.
# As this program is to test the functionality of the operations, 
#none of the function update initial_state matrix and always uses same initial_state as declared in cell [4]

initial_state= [[4, 5, 7], [0, 1, 6], [3, 8, 2]]

def move_left(initial_state):
  current_state = deepcopy(initial_state)
  i,j = 0,0
  n = len(current_state)
  flag=False
  ## Finding the 0 valued element ##
  for i in range(n):
    for j in range(n):
      if current_state[i][j] == 0:
        flag=True
        break
    if flag:break
  
  ## finding its left Neighbour ##
  ## no neighbour
  if (j-1) <0 :
    return None
  ## neighbour present
  else:
    current_state[i][j] = current_state[i][j-1]
    current_state[i][j-1] = 0
    return current_state

print('State after executing move_left operation  : ' , move_left(initial_state))

def move_right(initial_state):
  current_state = deepcopy(initial_state)
  i,j = 0,0
  n = len(current_state)
  flag=False
  ## Finding the 0 valued element ##
  for i in range(n):
    for j in range(n):
      if current_state[i][j] == 0:
        flag=True
        break
    if flag:break
  
  ## finding its right Neighbour ##

  ## no neighbour
  if (j+1) >n-1 :
    return None
  ## neighbour present
  else:
    current_state[i][j] = current_state[i][j+1]
    current_state[i][j+1] = 0
    return current_state

print('State after executing move_right operation : ' , move_right(initial_state))

def move_up(initial_state):
  current_state = deepcopy(initial_state)
  i,j = 0,0
  n = len(current_state)
  flag=False
  ## Finding the 0 valued element ##
  for i in range(n):
    for j in range(n):
      if current_state[i][j] == 0:
        flag=True
        break
    if flag:break
  
  ## finding its upper Neighbour ##

  ## no neighbour
  if (i-1) <0:
    return None
  ## neighbour present
  else:
    current_state[i][j] = current_state[i-1][j]
    current_state[i-1][j] = 0
    return current_state
  

print('State after executing move_up operation    : ' , move_up(initial_state))

def move_down(initial_state):
  current_state = deepcopy(initial_state)
  i,j = 0,0
  n = len(current_state)
  flag=False
  ## Finding the 0 valued element ##
  for i in range(n):
    for j in range(n):
      if current_state[i][j] == 0:
        flag=True
        break
    if flag:break
  
  ## finding its upper Neighbour ##

  ## no neighbour
  if (i+1) > n-1:
    return None
  ## neighbour present
  else:
    current_state[i][j] = current_state[i+1][j]
    current_state[i+1][j] = 0
    return current_state
  

print('State after executing move_down operation  : ' , move_down(initial_state))



def h1(neighbour,goal):
  h=0
  for i in range(len(neighbour)):
   for j in range(len(neighbour)):
    if neighbour[i][j] != goal[i][j] and neighbour[i][j]!=0:
      h=h+1
  return h

#driver code
start=[[6,7,2],[4,8,5],[1,3,0]]
goal = [[1,2,3],[4,5,6],[7,8,0]]
h1(start,goal)

def bfs_goal_search(start,goal):
    # keep track of all visited nodes
    explored = []
    # keep track of nodes to be checked
    queue = []
    queue1=[start]
    heapq.heappush(queue,[0,0,start])

    neighbour=[]
    parents=[]
    
    if(start==goal):
        return(print("start is goal"))

    count=0
    while queue:
        count+=1
        #print(c)
        node1=heapq.heappop(queue)
        node = node1[-1]
        
        print(node1)
        print('count=',count)
        g=node1[1]

        if node not in explored:
            # add node to list of checked nodes
            explored.append(node)

        neighbour = move_left(node)
        if neighbour != None:
            if neighbour == goal:
                print(count)
                return(neighbour)

            if (neighbour not in queue1) and (neighbour not in explored) :
                g1=g+1
                h=h1(neighbour,goal)
                heapq.heappush(queue,[g1+h,g1,neighbour])
                queue1.append(neighbour)
                parents.append([node,neighbour])
            if neighbour == goal:
                return neighbour
                    
        neighbour = move_right(node)
        if neighbour != None:
            if neighbour == goal:
                print(count)
                return(neighbour)

            if (neighbour not in queue1) and (neighbour not in explored) :
                g1=g+1
                h=h1(neighbour,goal)
                heapq.heappush(queue,[g1+h,g1,neighbour])
                queue1.append(neighbour)
                parents.append([node,neighbour])
            if neighbour == goal:
                return neighbour
        
        neighbour = move_up(node)
        if neighbour != None:
            if neighbour == goal:
                print(count)
                return(neighbour)

            if (neighbour not in queue1) and (neighbour not in explored) :
                g1=g+1
                h=h1(neighbour,goal)
                heapq.heappush(queue,[g1+h,g1,neighbour])
                queue1.append(neighbour)
                parents.append([node,neighbour])
            if neighbour == goal:
                return neighbour
            
        neighbour = move_down(node)
        if neighbour != None:
            if neighbour == goal:
                print(count)
                return(neighbour)

            if (neighbour not in queue1) and (neighbour not in explored) :
                g1=g+1
                h=h1(neighbour,goal)
                heapq.heappush(queue,[g1+h,g1,neighbour])
                queue1.append(neighbour)
                parents.append([node,neighbour])
            if neighbour == goal:
                return neighbour
            
     
# driver code      
start=[[4,5,7],[3,1,6],[8,2,0]]
goal =[[1,2,3],[4,5,6],[7,8,0]]
start_time = time()
bfs_goal_search(start,goal)
end_time = time()
print('time=',end_time-start_time)