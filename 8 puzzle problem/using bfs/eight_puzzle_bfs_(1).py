# -*- coding: utf-8 -*-
"""Eight_puzzle_BFS (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/146EjaQvJZKRLLakTK6JLwStgPTOj7-Kt
"""

from copy import deepcopy

def move_left(A):
  B = deepcopy(A)
  n = len(B)
  x = -1
  y = -1

  ## Finding the 0 valued element ##
  for i in range(n):
    for j in range(n):
      if B[i][j] == 0:
        x = i
        y = j
  
  ## finding its left Neighbour ##

  ## no neighbour
  if (y-1) <0 :
    return 
  ## neighbour present
  else:
    B[x][y] = B[x][y-1]
    B[x][y-1] = 0
  return B


def move_right(A):
  B = deepcopy(A)
  n = len(B)
  x = -1
  y = -1

  ## Finding the 0 valued element ##
  for i in range(n):
    for j in range(n):
      if B[i][j] == 0:
        x = i
        y = j
  
  
  ## finding its right Neighbour ##

  ## no neighbour
  if (y+1) >= n :
    return 
  ## neighbour present
  else:
    B[x][y] = B[x][y+1]
    B[x][y+1] = 0
  return B


def move_up(A):
  B = deepcopy(A)
  n = len(B)
  x = -1
  y = -1

  ## Finding the 0 valued element ##
  for i in range(n):
    for j in range(n):
      if B[i][j] == 0:
        x = i
        y = j
  
  
  ## finding its upper Neighbour ##

  ## no neighbour
  if (x-1) <0:
    return 
  ## neighbour present
  else:
    B[x][y] = B[x-1][y]
    B[x-1][y] = 0
  return B
  

def move_down(A):
  B = deepcopy(A)
  n = len(B)
  x = -1
  y = -1

  ## Finding the 0 valued element ##
  for i in range(n):
    for j in range(n):
      if B[i][j] == 0:
        x = i
        y = j
  
  
  ## finding its upper Neighbour ##

  ## no neighbour
  if (x+1) >= n:
    return 
  ## neighbour present
  else:
    B[x][y] = B[x+1][y]
    B[x+1][y] = 0
  return B
  
matrix= [[6,5,2],[8,7,1],[0,4,3]]
len(matrix)
  
print('Up    : ' , move_up(matrix))
print('Down  : ' , move_down(matrix))
print('Left  : ' , move_left(matrix))
print('Right : ' , move_right(matrix))

def  bfs(start,goal):
  queue = [start]
  neighbours = []
  explored = []
 
  c = 0
  if start == goal:
    return(print('start is the goal!!'))
  while queue:
    c = c+1
    parents = []
    node = queue.pop(0)
    print(c, node)
    if node not in explored:
      explored.append(node)


    child  = move_right(node)
    if child:
      if child not in explored and child not in queue:
        queue.append(child)
        parents.append([node,child])
      if child == goal:
        return child


    child  = move_left(node)
    if child:
      if child not in explored and child not in queue:
        queue.append(child)
        parents.append([node,child])
      if child == goal:
        return child


    child  = move_up(node)
    if child:
      if child not in explored and child not in queue:
        queue.append(child)
        parents.append([node,child])
      if child == goal:
        return child


    child  = move_down(node)
    if child:
      if child not in explored and child not in queue:
        queue.append(child)
        parents.append([node,child])
      if child == goal:
        return child

start=[[4,5,7],[3,1,6],[8,2,0]]
goal =[[1,2,3],[4,5,6],[7,8,0]]
bfs(start,goal)

